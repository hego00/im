// Code generated by xsdgen. DO NOT EDIT.

package ws

import "encoding/xml"

// May be one of
type Anon2 string

type EndpointReferenceType struct {
	Items               []string `xml:",any"`
	Address             string   `xml:"http://www.w3.org/2005/08/addressing Address"`
	ReferenceParameters string   `xml:"http://www.w3.org/2005/08/addressing ReferenceParameters,omitempty"`
	Metadata            string   `xml:"http://www.w3.org/2005/08/addressing Metadata,omitempty"`
}

type FaultCodesOpenEnumType string

// May be one of tns:InvalidAddressingHeader, tns:InvalidAddress, tns:InvalidEPR, tns:InvalidCardinality, tns:MissingAddressInEPR, tns:DuplicateMessageID, tns:ActionMismatch, tns:MessageAddressingHeaderRequired, tns:DestinationUnreachable, tns:ActionNotSupported, tns:EndpointUnavailable
type FaultCodesType xml.Name

type Lang string

type MetadataType []string

func (a MetadataType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	var output struct {
		ArrayType string   `xml:"http://schemas.xmlsoap.org/wsdl/ arrayType,attr"`
		Items     []string `xml:" item"`
	}
	output.Items = []string(a)
	start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{"", "xmlns:ns1"}, Value: "http://www.w3.org/2001/XMLSchema"})
	output.ArrayType = "ns1:anyType[]"
	return e.EncodeElement(&output, start)
}
func (a *MetadataType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) (err error) {
	var tok xml.Token
	for tok, err = d.Token(); err == nil; tok, err = d.Token() {
		if tok, ok := tok.(xml.StartElement); ok {
			var item string
			if err = d.DecodeElement(&item, &tok); err == nil {
				*a = append(*a, item)
			}
		}
		if _, ok := tok.(xml.EndElement); ok {
			break
		}
	}
	return err
}

type ProblemActionType struct {
	Action     string `xml:"http://www.w3.org/2005/08/addressing Action,omitempty"`
	SoapAction string `xml:"http://www.w3.org/2005/08/addressing SoapAction,omitempty"`
}

type ReferenceParametersType []string

func (a ReferenceParametersType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	var output struct {
		ArrayType string   `xml:"http://schemas.xmlsoap.org/wsdl/ arrayType,attr"`
		Items     []string `xml:" item"`
	}
	output.Items = []string(a)
	start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{"", "xmlns:ns1"}, Value: "http://www.w3.org/2001/XMLSchema"})
	output.ArrayType = "ns1:anyType[]"
	return e.EncodeElement(&output, start)
}
func (a *ReferenceParametersType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) (err error) {
	var tok xml.Token
	for tok, err = d.Token(); err == nil; tok, err = d.Token() {
		if tok, ok := tok.(xml.StartElement); ok {
			var item string
			if err = d.DecodeElement(&item, &tok); err == nil {
				*a = append(*a, item)
			}
		}
		if _, ok := tok.(xml.EndElement); ok {
			break
		}
	}
	return err
}

type RelatesToType struct {
	Value            string                   `xml:",chardata"`
	RelationshipType RelationshipTypeOpenEnum `xml:"RelationshipType,attr,omitempty"`
}

func (t *RelatesToType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T RelatesToType
	var overlay struct {
		*T
		RelationshipType *RelationshipTypeOpenEnum `xml:"RelationshipType,attr,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.RelationshipType = (*RelationshipTypeOpenEnum)(&overlay.T.RelationshipType)
	return d.DecodeElement(&overlay, &start)
}

// May be one of http://www.w3.org/2005/08/addressing/reply
type RelationshipType string

type RelationshipTypeOpenEnum string

// May be one of default, preserve
type Space string
